# 地理的クラスタリング機能 設計ドキュメント

## 概要

デイサービス送迎計画アプリケーションに地理的クラスタリング機能を追加し、自動割り当て時に地理的に近い利用者を同じ車両にグループ化することで、移動距離を最小化し、効率的な送迎計画を実現する。

## 目的

1. **移動距離の最小化**: 地理的に近い利用者を同じ車両に割り当てることで、総移動距離を削減
2. **送迎時間の短縮**: 効率的なルート構成により、送迎にかかる時間を短縮
3. **燃料費の削減**: 移動距離の削減により、燃料費を削減
4. **ドライバーの負担軽減**: 効率的なルート構成により、ドライバーの負担を軽減

## アルゴリズム選択

### K-means クラスタリング

**選択理由**:
- シンプルで実装が容易
- 計算コストが低い（O(n*k*i)、n=利用者数、k=クラスタ数、i=反復回数）
- 地理座標（緯度・経度）に対して効果的
- 車両数に応じてクラスタ数を動的に設定可能

**アルゴリズムの流れ**:
1. 利用者の座標データを取得
2. 車両数に基づいてクラスタ数（k）を決定
3. 初期クラスタ中心をランダムに選択
4. 各利用者を最も近いクラスタ中心に割り当て
5. 各クラスタの中心を再計算
6. 収束するまで4-5を繰り返し
7. 各クラスタを車両に割り当て

## 実装仕様

### 1. クラスタリングユーティリティの作成

**ファイル**: `/src/utils/geographicClustering.js`

**主要関数**:

#### `calculateDistance(lat1, lng1, lat2, lng2)`
- ハバーサイン公式を使用して2点間の距離を計算
- 単位: キロメートル

#### `kMeansClustering(users, k, maxIterations = 100)`
- K-meansアルゴリズムを実装
- パラメータ:
  - `users`: 利用者の配列（座標情報を含む）
  - `k`: クラスタ数（車両数）
  - `maxIterations`: 最大反復回数
- 戻り値: クラスタリング結果（各クラスタに属する利用者の配列）

#### `assignUsersToClusters(users, centroids)`
- 各利用者を最も近いクラスタ中心に割り当て

#### `updateCentroids(clusters)`
- 各クラスタの新しい中心座標を計算

### 2. 車椅子対応の考慮

**制約条件**:
- 車椅子対応が必要な利用者は、車椅子対応車両にのみ割り当て可能
- 各車両の車椅子定員を超えないように制御

**実装方法**:
1. 利用者を「車椅子対応が必要」と「一般」の2グループに分類
2. 車両を「車椅子対応可能」と「一般のみ」の2グループに分類
3. 各グループに対して個別にクラスタリングを実行
4. 車椅子対応車両には、車椅子利用者を優先的に割り当て
5. 残りの定員に一般利用者を割り当て

### 3. 車両定員の考慮

**制約条件**:
- 各車両の定員を超えないように制御
- 車椅子定員と一般定員を個別に管理

**実装方法**:
1. クラスタリング後、各クラスタの利用者数を確認
2. 定員を超える場合、超過分を他のクラスタに再割り当て
3. 再割り当て時は、最も近いクラスタ中心を持つ車両を選択

### 4. 複数便への対応

**実装方法**:
1. 1便目のクラスタリングと割り当てを実行
2. 各車両で定員を超えた利用者を抽出
3. 超過分の利用者に対して2便目のクラスタリングを実行
4. 必要に応じて3便目以降も同様に処理

### 5. App.jsxへの統合

**修正箇所**: `handleAutoAssign` 関数

**修正内容**:
1. 既存のシンプルな割り当てロジックを、地理的クラスタリングベースの割り当てに変更
2. 車椅子対応の制約を考慮
3. 車両定員の制約を考慮
4. 複数便の自動生成

## データ構造

### 入力データ

```javascript
// 利用者データ
{
  id: number,
  name: string,
  address: string,
  lat: number,
  lng: number,
  wheelchair: boolean,
  pickup_time: string,
  notes: string
}

// 車両データ
{
  id: number,
  name: string,
  driver: string,
  capacity: number,
  wheelchairCapacity: number,
  isActive: boolean
}
```

### 出力データ

```javascript
// クラスタリング結果
{
  vehicleId: number,
  trips: [
    {
      tripIndex: number,
      users: [
        // 利用者オブジェクトの配列
      ],
      totalDistance: number,
      estimatedTime: number
    }
  ]
}
```

## テスト計画

### 1. 単体テスト

- `calculateDistance`: 既知の座標間の距離が正しく計算されるか
- `kMeansClustering`: 小規模データセットで期待通りのクラスタが生成されるか
- `assignUsersToClusters`: 利用者が正しいクラスタに割り当てられるか

### 2. 統合テスト

- 車椅子対応の制約が正しく適用されるか
- 車両定員の制約が正しく適用されるか
- 複数便が正しく生成されるか

### 3. UIテスト

- 自動割り当てボタンをクリックして、利用者が車両に割り当てられるか
- 地図表示で、クラスタリング結果が視覚的に確認できるか
- 各車両のルートが地理的に効率的に見えるか

## パフォーマンス目標

- 30名の利用者、5台の車両の場合: 1秒以内
- 100名の利用者、10台の車両の場合: 3秒以内

## 今後の拡張可能性

1. **施設からの距離を考慮**: 施設から遠い利用者を優先的に割り当て
2. **時間制約の考慮**: 送迎時間の希望を考慮したクラスタリング
3. **道路ネットワークの考慮**: 直線距離ではなく、実際の道路距離を使用
4. **動的な車両数の決定**: 利用者数に応じて最適な車両数を自動決定
5. **機械学習の導入**: 過去の送迎実績から学習し、より効率的な割り当てを実現

## 実装スケジュール

1. **Phase 1**: クラスタリングユーティリティの実装（1-2時間）
2. **Phase 2**: App.jsxへの統合（1時間）
3. **Phase 3**: テストと調整（1時間）
4. **Phase 4**: ドキュメント作成（30分）

## 参考資料

- K-means clustering: https://en.wikipedia.org/wiki/K-means_clustering
- Haversine formula: https://en.wikipedia.org/wiki/Haversine_formula

